module Synthesis2OWL;
create OUT:OWL from IN:Synthesis;

-- =============================================================================
-- HELPERS
-- =============================================================================
	
helper def: primitiveTypeMap : Map(String, String) =
	Map {
		('string', 'http://www.w3.org/2001/XMLSchema#string'),
		('uint', 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger'),	
		('boolean', 'http://www.w3.org/2001/XMLSchema#boolean'),
		('int', 'http://www.w3.org/2001/XMLSchema#integer' )
	};
helper def: addNamespace( s : String ) : String = 'http://synthesis.ipi.ac.ru/' + s ;
helper context Synthesis!ClassDef def: hasInvariant() : Boolean =
	self.instanceType.attributes->asSequence()->select(t|t.type.oclIsTypeOf(Synthesis!InvariantDef))->notEmpty();
helper context Synthesis!ClassDef def: getInvariant() : Synthesis!Invariant =
	self.instanceType.attributes->asSequence()->select( t | t.type.oclIsTypeOf(Synthesis!InvariantDef))->
	collect(t|t.type).first();

helper context Synthesis!Atom def: intersectionCheck() : Boolean =
		if self.oclIsTypeOf(Synthesis!SetPredicate) then
		   if self.symbol = '<=' then
		   let pterms:Sequence(Synthesis!ValueDef) = self.terms->asSequence()
		   in
		   		if pterms->at(1)->oclIsTypeOf(Synthesis!ClassDef)
				   and self.terms->at(2)->oclIsTypeOf(Synthesis!BuiltInFunction) then
				   if self.terms->at(2).name = 'intersect' then
				      true
				   else 
				   	  false
				   endif
				 else
				 	false
				 endif
		   else
		      false
		   endif
		else
			false
		endif;

helper context Synthesis!Atom def: unionCheck() : Boolean =
		if self.oclIsTypeOf(Synthesis!SetPredicate) then
		   if self.symbol = '<=' then
		   let pterms:Sequence(Synthesis!ValueDef) = self.terms->asSequence()
		   in
		   		if pterms->at(1)->oclIsTypeOf(Synthesis!ClassDef)
				   and self.terms->at(2)->oclIsTypeOf(Synthesis!BuiltInFunction) then
				   if self.terms->at(2).name = 'union' then
				      true
				   else 
				   	  false
				   endif
				 else
				 	false
				 endif
		   else
		      false
		   endif
		else
			false
		endif;

helper context Synthesis!ClassDef def: isIntersectionClass() : Boolean =
	if self.hasInvariant() then
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		let atoms : Sequence(Synthesis!Atom) = p.splitToAtoms()
		in
			if atoms->select(t|t.intersectionCheck()).notEmpty() then
				true
			else
				false
			endif
	 else
	 	false
	 endif;

helper context Synthesis!ClassDef def: isUnionClass() : Boolean =
	if self.hasInvariant() then
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		let atoms : Sequence(Synthesis!Atom) = p.splitToAtoms()
		in
			if atoms->select(t|t.unionCheck()).notEmpty() then
				true
			else
				false
			endif
	 else
	 	false
	 endif;


helper context Synthesis!Atom def: containmentCheck() : Boolean = 
	if self.oclIsTypeOf(Synthesis!SetPredicate) then
		if self.symbol = '<=' then
			true
		else
			false
		endif
	else
		false
	endif;

helper context Synthesis!ClassDef def: hasContainmentInvariant(): Boolean =
	if self.hasInvariant() then 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.splitToAtoms()->select(t|t.containmentCheck())->notEmpty() then
			true
		else
			false
		endif
	else
		false
	endif;

helper context Synthesis!Atom def: equivalenceCheck() : Boolean = 
	if self.oclIsTypeOf(Synthesis!BuiltInPredicate) then
		if self.symbol = 'is_equal' then
			true
		else
			false
		endif
	else
		false
	endif;
helper context Synthesis!ClassDef def: hasEquivalenceInvariant(): Boolean =
	if self.hasInvariant() then 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.splitToAtoms()->select(t|t.equivalenceCheck())->notEmpty() then
			true
		else
			false
		endif
	else
		false
	endif;
	
helper context Synthesis!ValueDef def: extractClassesRecursive() : Sequence(Synthesis!ClassDef) = 
	if self.oclIsTypeOf(Synthesis!ClassDef) then
		Sequence{self}
	else
		if self.oclIsKindOf(Synthesis!FunctionCall) and self.terms->asSequence()->size()=2 then
			self.terms->asSequence()->at(1)->extractClassesRecursive()->union(self.terms->asSequence()->at(2)->extractClassesRecursive())
		else
			Sequence{}
		endif
	endif;
			
		
helper context Synthesis!Formula def: getIntersectionAtom() : Synthesis!Atom = 
	self.splitToAtoms()->select(t|t.intersectionCheck())->first();

helper context Synthesis!Formula def: getUnionAtom() : Synthesis!Atom = 
	self.splitToAtoms()->select(t|t.unionCheck())->first();
helper context Synthesis!ClassDef def: getIntersectionClasses() : Sequence( Synthesis!ClassDef ) = 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		p.getIntersectionAtom().terms->select(t | t.oclIsTypeOf(Synthesis!BuiltInFunction))->first().extractClassesRecursive();
helper context Synthesis!ClassDef def: getUnionClasses() : Sequence( Synthesis!ClassDef ) = 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		p.getUnionAtom().terms->select(t | t.oclIsTypeOf(Synthesis!BuiltInFunction))->first().extractClassesRecursive();

helper context Synthesis!ClassDef def: getClassesFromPredicativeSpec() : Sequence( Synthesis!ClassDef )	=
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		p.splitToAtoms()->select(t|t.intersectionCheck())->collect(t|t.terms)->flatten()->
			select(t | t.oclIsTypeOf(Synthesis!BuiltInFunction))->first().extractClassesRecursive();
		--p.terms->asSequence()->select(t | t.oclIsTypeOf(Synthesis!BuiltInFunction))->first().extractClassesRecursive();

 
helper def: getIntegerURI() : OclAny =
	thisModule.resolveTemp( 
		Synthesis!ScalarDef.allInstances()->any( e |
			e.oclIsTypeOf(Synthesis!IntegerDef)  and e.name = 'int' ),
			'u'
	);

helper context Synthesis!AssociationMetaclassDef def: getClassesWithProperty(): Sequence( Synthesis!ClassDef ) = 
	Synthesis!ClassDef.allInstances()->
	asSequence()->
	select(t|t.oclIsTypeOf(Synthesis!ClassDef))->select(t | if(t.instanceType.attributes->notEmpty()) then
		t.instanceType.attributes->asSequence()->
		select(a|a.classes.includes(self))->notEmpty()
		else false
		endif);

	
helper context Synthesis!CollectionComprehension def: isCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate)
		and self.formula.symbol = '==' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerValueDef)) then
					if p.terms->asSequence()->at(1).name = 'cardinal' and 
					   p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!GetFunction)
					then
						true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;

helper context Synthesis!CollectionComprehension def: isMinCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate) and
		self.formula.symbol = '>=' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerValueDef)) then
					if p.terms->asSequence()->at(1).name='cardinal' and 
					   p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!GetFunction)
					then
						true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;
helper context Synthesis!CollectionComprehension def: isSomeValuesFromInvariant(): Boolean = 
	if self.formula.oclIsTypeOf(Synthesis!ExsistentiallyQuantifiedFormula) then 
		let 
			p : Synthesis!Formula = self.formula.formula
		in
			if (p.oclIsTypeOf(Synthesis!Conjunction)) then
				if p.formula->size() = 2 then
					let	op1:Synthesis!Formula = p.formula->at(1) in
					let op2:Synthesis!Formula = p.formula->at(2) in
						if op1.oclIsTypeOf(Synthesis!BuiltInPredicate) then
							if op2.oclIsTypeOf(Synthesis!BuiltInPredicate) then
								if op1.symbol = 'is_in' and op2.symbol = 'is_in' then
									if (op1.terms->at(2)=self.formula.var) and 
									   (op2.terms->at(2)=self.formula.var) and
									   (op1.oclIsTypeOf(Synthesis!GetFunction)) and 
									   (op2.oclIsTypeOf(Synthesis!ClassName)) then
									   	true
									else
										false
									endif
								else
									false
								endif
							else
								false
							endif
						else
							false
						endif
				else
					false
				endif
			else
				false
			endif
	else
		false
	endif;
										
									
										
			   

helper context Synthesis!CollectionComprehension def: isMaxCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate) and
		self.formula.symbol = '<=' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerValueDef)) then
					if p.terms->asSequence()->at(1).name='cardinal' and 
					p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!GetFunction)
					then
					true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;

helper context Synthesis!CollectionComprehension def: checkForPropertyRestrictions(): Boolean =
	self.isCardinalityInvariant() or self.isMinCardinalityInvariant() or self.isMaxCardinalityInvariant();

helper context Synthesis!CollectionComprehension def: getCardinalityValue(): String =
	self.formula.terms->asSequence()->at(2).value;

helper context Synthesis!CollectionComprehension def: getOnProperty(): Synthesis!AttributeDef =
	self.formula.terms->asSequence()->at(1).terms->asSequence()->at(1).attribute;

helper context Synthesis!Atom def: propertyRestrictionCheck(): Boolean = 
	let pterms : Sequence(Synthesis!ValueDef) = self.terms->asSequence()
	in
		if pterms->at(1).oclIsTypeOf(Synthesis!ClassDef) and
		   pterms->at(2).oclIsTypeOf(Synthesis!CollectionComprehension) then
			if pterms->at(2).checkForPropertyRestrictions() then
				true
			else
				false
			endif
		else
			false
		endif;
helper context Synthesis!ClassDef def: hasPropertyRestrictionInvariant(): Boolean = 
	if self.hasContainmentInvariant() then
		let p : Synthesis!Formula = self.getInvariant().predicativeSpec
		in 
			if p.splitToAtoms()->select(t|t.propertyRestrictionCheck())->notEmpty() then
		    	true
			else 
				false
			endif
	else
		false
	endif;

helper context Synthesis!ClassDef def: extractPropertyRestrictions(): Sequence(Synthesis!CollectionComprehension) =
	let p: Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		p.splitToAtoms()->select(t|t.propertyRestrictionCheck())->collect(t|t.terms->asSequence()->at(2));
helper context Synthesis!ClassDef def: extractCollectionComprehension(): Synthesis!CollectionComprehension = 
	self.getInvariant().predicativeSpec.terms->asSequence()->at(2);

helper context Synthesis!Formula def: splitToAtoms(): Sequence(Synthesis!Atom) =
	if self.oclIsKindOf(Synthesis!Atom) then
		Sequence{self}
	else
		if self.oclIsTypeOf(Synthesis!Negation) then
			self.formula.splitToAtoms()
		else
			if self.oclIsTypeOf(Synthesis!Conjunction) or self.oclIsTypeOf(Synthesis!Disjunction) then
				self.formula->asSequence()->at(1).splitToAtoms()->union(self.formula->asSequence()->at(2).splitToAtoms())
			else
				if self.oclIsTypeOf(Synthesis!Implication) then
					self.antecedent.splitToAtoms()->union(self.consequent.splitToAtoms())
				else
					if self.oclIsKindOf(Synthesis!QuantifiedFormula) then 
						self.formula.splitToAtoms()
					else
						Sequence{}
					endif
				endif
			endif
		endif
	endif;
				
		
				   
			
-- =============================================================================
-- RULES
-- =============================================================================


rule SynthesisModule2OWLOntology {
	from 
		m : Synthesis!ModuleDef (
			m.oclIsTypeOf(Synthesis!ModuleDef)
		)
	to
		g : OWL!OWLGraph (
			ontology <- o
			),
		o : OWL!OWLOntology (
			OWLImports <- m.imports->asSequence(),
			owlUniverse <- Synthesis!ClassDef.allInstances()->asSequence()->select(k | m.containedClasses->asSequence()->includes(k)),
			uriRef <- u
		),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- m.name),
		uri : OWL!UniformResourceIdentifier (
			name <- thisModule.addNamespace(m.name)
		)

}


rule ScalarType2RDFSDataType {
	from
		p : Synthesis!ScalarDef
	to
		d : OWL!RDFSDataType (
			uriRef <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( 
			name <- thisModule.primitiveTypeMap.get(p.name) 
		)
}


 rule OrdinaryClass2OWLClass {
	from
		c : Synthesis!ClassDef (
				if c.oclIsTypeOf(Synthesis!ClassDef) then
					if not c.instanceType.oclIsUndefined() 
				 then if c.hasInvariant() then
				  false
				  else true
				  endif
				  else
				  	false
					endif
					else false
					endif) 
	to
		oc : OWL!OWLClass (
			subClassOf <- c.superclasses,
			uriRef <- uri,
			label <- label,
			stringRepr <- c.instanceType.name
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )	
}
 
rule RestrictedClass2OWLClass {
	from
		c : Synthesis!ClassDef (
				if c.oclIsTypeOf(Synthesis!ClassDef) then
					if not c.instanceType.oclIsUndefined() 
				 then if c.hasPropertyRestrictionInvariant() then
				  true
				  else false
				  endif
				  else
				  	false
					endif
					else false
					endif) 	
	to
				oc : OWL!OWLClass (
			subClassOf <- c.superclasses,
			uriRef <- uri,
			label <- label,
			stringRepr <- c.instanceType.name
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )	
	do {
		for(p in c.extractPropertyRestrictions()) {
			if (p.isCardinalityInvariant()) {
				thisModule.addCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
					p.getCardinalityValue());
			} else {
				if (p.isMaxCardinalityInvariant()) {
					thisModule.addMaxCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				} else {
					if (p.isMinCardinalityInvariant()) {
						thisModule.addMinCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				}
			}
		}
		}
	}
		
	
}
 rule IntersectionClass2OWLIntersection {
 	from 
		c : Synthesis!ClassDef (
			if c.oclIsTypeOf(Synthesis!ClassDef) then
				if not c.instanceType.oclIsUndefined() 
				 then if c.isIntersectionClass() then
				  true
				  else false
				  endif
				  else
				  	false
					endif
					else false
					endif)
	to
		oc: OWL!IntersectionClass (
			subClassOf <- c.superclasses,
			OWLIntersectionOf <- c.getIntersectionClasses(),
			uriRef <- uri,
			label <- label,
			stringRepr <- c.instanceType.name),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )
	do {
		if (c.hasPropertyRestrictionInvariant()){
					for(p in c.extractPropertyRestrictions()) {
			if (p.isCardinalityInvariant()) {
				thisModule.addCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
					p.getCardinalityValue());
			} else {
				if (p.isMaxCardinalityInvariant()) {
					thisModule.addMaxCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				} else {
					if (p.isMinCardinalityInvariant()) {
						thisModule.addMinCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				}
			}
		}
		}
		}
	}
 }
 
  rule UnionClass2OWLUnion {
 	from 
		c : Synthesis!ClassDef (
			if c.oclIsTypeOf(Synthesis!ClassDef) then
				if not c.instanceType.oclIsUndefined() 
				 then if c.isUnionClass() then
				  true
				  else false
				  endif
				  else
				  	false 
					endif
					else false
					endif)
	to
		oc: OWL!UnionClass (
			subClassOf <- c.superclasses,
			OWLUnionOf <- c.getUnionClasses(),
			uriRef <- uri,
			label <- label,
			stringRepr <- c.instanceType.name),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )
			do {
		if (c.hasPropertyRestrictionInvariant()){
					for(p in c.extractPropertyRestrictions()) {
			if (p.isCardinalityInvariant()) {
				thisModule.addCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
					p.getCardinalityValue());
			} else {
				if (p.isMaxCardinalityInvariant()) {
					thisModule.addMaxCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				} else {
					if (p.isMinCardinalityInvariant()) {
						thisModule.addMinCardinalityRestrictionToClass(c,p.getOnProperty().classes->asSequence()->first(),
						p.getCardinalityValue());
				}
			}
		}
		}
		}
	}
 }
 
 
 

rule AssociationMetaclass2SOWLObjectProperty {
	from 
		am : Synthesis!AssociationMetaclassDef
	to
		op : OWL!OWLObjectProperty (
			domain <- am.domain,
			range <- am.range,
			OWLInverseOf <- am.inverse,
			subPropertyOf <- am.superclasses,
			uriRef <- o_u),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- am.inverse.name + '.' + am.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- am.inverse.name + '.' + am.name )
	do {
		if (( am.minCard = 1) and (am.maxCard = 1))
				thisModule.addFunctionalProperty(am);
		if(am.minCard = am.maxCard) {
			thisModule.addCardinalityRestriction(am);
		} else {
			if (( am.maxCard = 0-1 ) and ( am.minCard >= 0 )) {-- [*]
					thisModule.addMinCardinalityRestriction(am);
			} else { -- [m-n]
					thisModule.addMinCardinalityRestriction(am);
					thisModule.addMaxCardinalityRestriction(am);
			}
		}
	}
		

}

rule addFunctionalProperty(am : Synthesis!AssociationMetaclassDef) {
	to
		 o : OWL!FunctionalProperty (
		 	isDefinedBy <- am)
}
-- =============================================================================
-- OWL Restrictions
-- =============================================================================
rule addCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										card: String) {
	to
		r: OWL!CardinalityRestriction(
			superClass <- c,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- card,
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										minCard: String) {
	to
		r: OWL!MinCardinalityRestriction(
			superClass <- c,
			OWLMinCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- minCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										maxCard: String) {
	to
		r: OWL!MaxCardinalityRestriction(
			superClass <- c,
			OWLMaxCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- maxCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addHasValueRestrictionToClass ( c: Synthesis!ClassDef,
									 p: Synthesis!AssociationMetaclassDef,
									 value: Synthesis!ValueDef) {
	to
		r: OWL!HasValueRestriction(
			superclass <- c,
			OWLHasLiteralValue <- literal,
			OWLOnProperty <- p)
			,
			literal : OWL!RDFSLiteral (
				lexicalForm <- value.toString())
}

rule addSomeValuesFromRestrictionToClass (c: Synthesis!ClassDef,
										 p: Synthesis!AssociationMetaclassDef,
										 fromClass: Synthesis!ClassDef) {
	to
		r: OWL!SomeValuesFromRestriction(
			superclass <- c,
			OWLSomeValuesFromClass <- fromClass,
			OWLOnProperty <- p)
}

rule addAllValuesFromRestrictionToClass (c: Synthesis!ClassDef,
										 p: Synthesis!AssociationMetaclassDef,
										 fromClass: Synthesis!ClassDef ) {
	to
		r: OWL!AllValuesFromRestriction(
			superclass <- c,
			OWLAllValueFromClass <- fromClass)
}

rule addCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!CardinalityRestriction (
			superClass <- p.getClassesWithProperty(),
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.maxCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!MaxCardinalityRestriction (
			superClass <-p.getClassesWithProperty(),
			OWLMaxCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.maxCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!MinCardinalityRestriction (
			superClass <- p.getClassesWithProperty(),
			OWLMinCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.minCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}
rule addFunctionalProperty( am : Synthesis!AssociationMetaclassDef ) {
	to
		o : OWL!FunctionalProperty (
				isDefinedBy <- am
		)
}




-- =============================================================================
-- BOOLEAN OPERATIONS
-- =============================================================================

rule addIntersectionToClass ( classesInIntersection : Sequence(Synthesis!ClassDef),
							  c : Synthesis!ClassDef) {
	to
		intersection : OWL!IntersectionClass (
			superClass <- c,
			OWLIntersectionOf <- classesInIntersection)
}
rule addUnionToClass ( classesInUnion : Sequence(Synthesis!ClassDef),
							  c : Synthesis!ClassDef) {
	to
		union : OWL!UnionClass (
			superClass <- c,
			OWLUnionOf <- classesInUnion)
}
rule addComplementToClass ( complementClasses : Sequence(Synthesis!ClassDef),
							c: Synthesis!ClassDef) {
	to
		complement: OWL!ComplementClass (
			superClass <- c,
			OWLComplementOf <- complementClasses)
}


-- TODO: Property restrictions
-- =============================================================================
-- INDIVIDUALS
-- =============================================================================
rule Frame2Individual {
	from 
		i : Synthesis!FrameDef (
			i.oclIsTypeOf(Synthesis!FrameDef) and
			i.classes->asSequence()->notEmpty() and 
			Synthesis!ClassDef.allInstances()->asSequence()->includesAll(i.classes->asSequence())
			)
	to
		owlIndividual: OWL!Individual(
			uriRef <- u,
			type <- i.classes->asSequence()),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri),
		l : OWL!LocalName (name <- i.name),
		uri: OWL!UniformResourceIdentifier (name <- i.name)
}