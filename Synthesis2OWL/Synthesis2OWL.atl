module Synthesis2OWL;
create OUT:OWL from IN:Synthesis;

-- =============================================================================
-- HELPERS
-- =============================================================================
	
helper def: primitiveTypeMap : Map(String, String) =
	Map {
		('string', 'http://www.w3.org/2001/XMLSchema#string'),
		('uint', 'http://www.w3.org/2001/XMLSchema#nonNegativeInteger'),	
		('boolean', 'http://www.w3.org/2001/XMLSchema#boolean'),
		('int', 'http://www.w3.org/2001/XMLSchema#integer' )
	};
helper def: addNamespace( s : String ) : String = 'http://synthesis.ipi.ac.ru/' + s ;
helper context Synthesis!ClassDef def: hasInvariant() : Boolean =
	not self.getInvariant().oclIsUndefined();
helper context Synthesis!ClassDef def: getInvariant() : Synthesis!Invariant =
	self.instanceType.attributes->asSequence()->select( t | t.type.oclIsTypeOf(Synthesis!InvariantDef))->
	collect(t|t.type).first();
helper context Synthesis!ClassDef def: isIntersectionClass() : Boolean =
	if self.hasInvariant() then
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.oclIsTypeOf(Synthesis!SetPredicate) then
		   if p.symbol = '<=' then
		   let pterms:Sequence(Synthesis!Term) = p.terms->asSequence()
		   in
		   		if pterms->at(1)->oclIsTypeOf(Synthesis!ClassName)
				   and p.terms->at(2)->oclIsTypeOf(Synthesis!BuiltInFunction) then
				   if p.terms->at(2).name = 'intersect' then
				      true
				   else 
				   	  false
				   endif
				 else
				 	false
				 endif
		   else
		      false
		   endif
		else
			false
		endif
	 else
	 	false
	 endif;

helper context Synthesis!ClassDef def: isUnionClass() : Boolean =
	if self.hasInvariant() then
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.oclIsTypeOf(Synthesis!SetPredicate) then
		   if p.symbol = '<=' then
		   let pterms:Sequence(Synthesis!Term) = p.terms->asSequence()
		   in
		   		if pterms->at(1)->oclIsTypeOf(Synthesis!ClassName)
				   and p.terms->at(2)->oclIsTypeOf(Synthesis!BuiltInFunction) then
				   if p.terms->at(2).name = 'union' then
				      true
				   else 
				   	  false
				   endif
				 else
				 	false
				 endif
		   else
		      false
		   endif
		else
			false
		endif
	 else
	 	false
	 endif;

helper context Synthesis!ClassDef def: hasContainmentInvariant(): Boolean =
	if self.hasInvariant() then 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.oclIsTypeOf(Synthesis!SetPredicate) then
			if p.symbol = '<=' then 
				true
			else
				false
			endif
		else
			false
		endif
	else
		false
	endif;

helper context Synthesis!ClassDef def: hasEquivalenceInvariant(): Boolean =
	if self.hasInvariant() then 
	let p : Synthesis!Formula = self.getInvariant().predicativeSpec
	in
		if p.oclIsTypeOf(Synthesis!BuiltInPredicate) then
			if p.symbol = 'is_equal' then 
				true
			else
				false
			endif
		else
			false
		endif
	else
		false
	endif;
	
helper context Synthesis!Term def: extractClassesRecursive() : Sequence(Synthesis!ClassDef) = 
	if self.oclIsTypeOf(Synthesis!ClassName) then
		Sequence{self.classNameOf}
	else
		if self.oclIsKindOf(Synthesis!FunctionCall) and self.terms->asSequence()->size()=2 then
			self.terms->asSequence()->at(1)->extractClassesRecursive()->union(self.terms->asSequence()->at(2)->extractClassesRecursive())
		else
			Sequence{}
		endif
	endif;
			
		
	
helper context Synthesis!ClassDef def: getClassesFromPredicativeSpec() : Sequence( Synthesis!ClassDef )	=
	let p : Synthesis!Atom = self.getInvariant().predicativeSpec
	in
		--p.terms->asSequence()->select(t | t.oclIsTypeOf(Synthesis!Predicate))->first().terms->asSequence()->select(t|t.oclIsTypeOf(Synthesis!ClassDef));
		p.terms->asSequence()->select(t | t.oclIsTypeOf(Synthesis!BuiltInFunction))->first().extractClassesRecursive();
	  
helper def: getIntegerURI() : OclAny =
	thisModule.resolveTemp( 
		Synthesis!ScalarDef.allInstances()->any( e |
			e.oclIsTypeOf(Synthesis!IntegerDef)  and e.name = 'int' ),
			'u'
	);

helper context Synthesis!AssociationMetaclassDef def: getClassesWithProperty(): Sequence( Synthesis!ClassDef ) = 
	Synthesis!ClassDef.allInstances()->
	asSequence()->
	select(t|t.oclIsTypeOf(Synthesis!ClassDef))->select(t | 
		t.instanceType.attributes->asSequence()->
		select(a|a.classes.includes(self))->notEmpty());

	
helper context Synthesis!CollectionComprehension def: isCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate)
		and self.formula.symbol = '=' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerConstant)) then
					if p.terms->asSequence()->at(1).name='cardinal' and 
					p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!AttributeName)
					then
					true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;

helper context Synthesis!CollectionComprehension def: isMinCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate) and
		self.formula.symbol = '>=' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerConstant)) then
					if p.terms->asSequence()->at(1).name='cardinal' and 
					p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!AttributeName)
					then
					true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;

helper context Synthesis!CollectionComprehension def: isMaxCardinalityInvariant(): Boolean =
	if self.formula.oclIsTypeOf(Synthesis!ArithmeticPredicate) and
		self.formula.symbol = '<=' 
		then
		let p : Synthesis!ArithmeticPredicate = self.formula 
		in
			if(p.terms->asSequence()->at(1).oclIsTypeOf(Synthesis!BuiltInFunction) and
					p.terms->asSequence()->at(2).oclIsTypeOf(Synthesis!IntegerConstant)) then
					if p.terms->asSequence()->at(1).name='cardinal' and 
					p.terms->asSequence()->at(1).terms->asSequence()->at(1).oclIsTypeOf(Synthesis!AttributeName)
					then
					true
					else
						false
					endif
			else
				false
			endif
	else
		false
	endif;

helper context Synthesis!CollectionComprehension def: checkForPropertyRestrictions(): Boolean =
	self.isCardinalityInvariant() or self.isMinCardinalityInvariant() or self.isMaxCardinalityInvariant();

helper context Synthesis!ClassDef def: getCardinalityValue(): String =
	self.getInvariant().predicativeSpec.terms->asSequence()->at(2).formula.terms->asSequence()->at(2).value;

helper context Synthesis!ClassDef def: getOnProperty(): Synthesis!AttributeDef =
	self.getInvariant().predicativeSpec.terms->asSequence()->at(2).formula.terms->asSequence()->at(1).terms->asSequence()->at(1).attributeNameOf;

helper context Synthesis!ClassDef def: hasPropertyRestrictionInvariant(): Boolean = 
	if self.hasContainmentInvariant() then
		let p : Synthesis!SetPredicate = self.getInvariant().predicativeSpec
		in 
		   let pterms : Sequence(Synthesis!Term) = p.terms->asSequence()
		   in
		   		if pterms->at(1).oclIsTypeOf(Synthesis!ClassName) and
		   		   pterms->at(2).oclIsTypeOf(Synthesis!CollectionComprehension) then
				   if pterms->at(2).checkForPropertyRestrictions() then
				      true
				   else
				   	  false
				   endif
				else
					false
				endif
	else
		false
	endif;

helper context Synthesis!ClassDef def: extractCollectionComprehension(): Synthesis!CollectionComprehension = 
	self.getInvariant().predicativespec.terms->asSequence()->at(2);


				   
			
-- =============================================================================
-- RULES
-- =============================================================================
--
--
--rule SynthesisModule2OWLOntology {
--	from 
--		m : Synthesis!ModuleDef (
--			m.oclIsTypeOf(Synthesis!ModuleDef)
--		)
--	to
--		o : OWL!OWLOntology (
--			OWLImports <- m.imports->asSequence(),
--			owlUniverse <- Synthesis!ClassDef.allInstances()->asSequence()->select(k | m.containedClasses->asSequence()->includes(k)),
--			-- owlGraph <- Synthesis!ClassDef.allInstances()->asSequence(),
--			uriRef <- u
--		),
--		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri ),
--		l : OWL!LocalName ( name <- m.name),
--		uri : OWL!UniformResourceIdentifier (
--			name <- thisModule.addNamespace(m.name)
--		)
--}
--

rule ScalarType2RDFSDataType {
	from
		p : Synthesis!ScalarDef
	to
		d : OWL!RDFSDataType (
			uriRef <- u
		),
		u : OWL!URIReference (
			uri <- uri
		),
		uri : OWL!UniformResourceIdentifier ( 
			name <- thisModule.primitiveTypeMap.get(p.name) 
		)
}


 rule OrdinaryClass2OWLClass {
	from
		c : Synthesis!ClassDef (
				if c.oclIsTypeOf(Synthesis!ClassDef) then
					if not c.instanceType.oclIsUndefined() 
				 then if c.hasInvariant() then
				  false
				  else true
				  endif
				  else
				  	false
					endif
					else false
					endif) 
	to
		oc : OWL!OWLClass (
			subClassOf <- c.superclasses,
			uriRef <- uri,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )	
}
 
rule RestrictedClass2OWLClass {
	from
		c : Synthesis!ClassDef (
				if c.oclIsTypeOf(Synthesis!ClassDef) then
					if not c.instanceType.oclIsUndefined() 
				 then if c.hasPropertyRestrictionInvariant() then
				  true
				  else false
				  endif
				  else
				  	false
					endif
					else false
					endif) 	
	to
				oc : OWL!OWLClass (
			subClassOf <- c.superclasses,
			uriRef <- uri,
			label <- label
		),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )	
	do {
		if (c.extractCollectionComprehesion().isCardinalityInvariant()) {
			thisModule.addCardinalityRestrictionToClass(c,c.getOnProperty().classes->asSequence()->first(),c.getCardinalityValue());
		} else {
			if (c.extractCollectionComprehension().isMaxCardinalityInvariant()) {
				thisModule.addMaxCardinalityRestrictionToClass(c,c.getOnProperty().classes->asSequence()->first(),
					c.getCardinalityValue());
			} else {
				if (c.extractCollectionComprehension().isMinCardinalityInvariant()) {
					thisModule.addMinCardinalityRestrictionToClass(c,c.getOnProperty().classes->asSequence()->first(),
					c.getCardinalityValue());
				}
			}
		}
	}
		
	
}
 rule IntersectionClass2OWLIntersection {
 	from 
		c : Synthesis!ClassDef (
			if c.oclIsTypeOf(Synthesis!ClassDef) then
				if not c.instanceType.oclIsUndefined() 
				 then if c.isIntersectionClass() then
				  true
				  else false
				  endif
				  else
				  	false
					endif
					else false
					endif)
	to
		oc: OWL!IntersectionClass (
			subClassOf <- c.superclasses,
			OWLIntersectionOf <- c.getClassesFromPredicativeSpec(),
			uriRef <- uri,
			label <- label),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )
 }
 
  rule UnionClass2OWLUnion {
 	from 
		c : Synthesis!ClassDef (
			if c.oclIsTypeOf(Synthesis!ClassDef) then
				if not c.instanceType.oclIsUndefined() 
				 then if c.isUnionClass() then
				  true
				  else false
				  endif
				  else
				  	false 
					endif
					else false
					endif)
	to
		oc: OWL!IntersectionClass (
			subClassOf <- c.superclasses,
			OWLUnionOf <- c.getClassesFromPredicativeSpec(),
			uriRef <- uri,
			label <- label),
		label : OWL!PlainLiteral ( lexicalForm <- c.instanceType.name ),
		u : OWL!URIReference (	fragmentIdentifier <- l, uri <- uri ),
		l : OWL!LocalName ( name <- c.instanceType.name ),
		uri : OWL!UniformResourceIdentifier ( name <- c.instanceType.name )
 }
 
 
 

rule AssociationMetaclass2SOWLObjectProperty {
	from 
		am : Synthesis!AssociationMetaclassDef
	to
		op : OWL!OWLObjectProperty (
			domain <- am.domain,
			range <- am.range,
			OWLInverseOf <- am.inverse,
			subPropertyOf <- am.superclasses,
			uriRef <- o_u),
		o_u : OWL!URIReference ( fragmentIdentifier <- o_l, uri <- o_uri ),
		o_l : OWL!LocalName ( name <- am.inverse.name + '.' + am.name ),
		o_uri : OWL!UniformResourceIdentifier ( name <- am.inverse.name + '.' + am.name )
	do {
		if (( am.minCard = 1) and (am.maxCard = 1))
				thisModule.addFunctionalProperty(am);
		if(am.minCard = am.maxCard) {
			thisModule.addCardinalityRestriction(am);
		} else {
			if (( am.maxCard = 0-1 ) and ( am.minCard >= 0 )) {-- [*]
					thisModule.addMinCardinalityRestriction(am);
			} else { -- [m-n]
					thisModule.addMinCardinalityRestriction(am);
					thisModule.addMaxCardinalityRestriction(am);
			}
		}
	}
		

}

rule addFunctionalProperty(am : Synthesis!AssociationMetaclassDef) {
	to
		 o : OWL!FunctionalProperty (
		 	isDefinedBy <- am)
}
-- =============================================================================
-- OWL Restrictions
-- =============================================================================
rule addCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										card: String) {
	to
		r: OWL!CardinalityRestriction(
			superClass <- c,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- card,
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										minCard: String) {
	to
		r: OWL!MaxCardinalityRestriction(
			superClass <- c,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- minCard,
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinalityRestrictionToClass ( c: Synthesis!ClassDef, 
										p: Synthesis!AssociationMetaclassDef,
										maxCard: String) {
	to
		r: OWL!MaxCardinalityRestriction(
			superClass <- c,
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- maxCard,
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addHasValueRestrictionToClass ( c: Synthesis!ClassDef,
									 p: Synthesis!AssociationMetaclassDef,
									 value: Synthesis!ValueDef) {
	to
		r: OWL!HasValueRestriction(
			superclass <- c,
			OWLHasLiteralValue <- literal,
			OWLOnProperty <- p)
			,
			literal : OWL!RDFSLiteral (
				lexicalForm <- value.toString())
}

rule addSomeValuesFromRestrictionToClass (c: Synthesis!ClassDef,
										 p: Synthesis!AssociationMetaclassDef,
										 fromClass: Synthesis!ClassDef) {
	to
		r: OWL!SomeValuesFromRestriction(
			superclass <- c,
			OWLSomeValuesFromClass <- fromClass,
			OWLOnProperty <- p)
}

rule addAllValuesFromRestrictionToClass (c: Synthesis!ClassDef,
										 p: Synthesis!AssociationMetaclassDef,
										 fromClass: Synthesis!ClassDef ) {
	to
		r: OWL!AllValuesFromRestriction(
			superclass <- c,
			OWLAllValueFromClass <- fromClass)
}

rule addCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!CardinalityRestriction (
			superClass <- p.getClassesWithProperty(),
			OWLCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.maxCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMaxCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!MaxCardinalityRestriction (
			superClass <-p.getClassesWithProperty(),
			OWLMaxCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.maxCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}

rule addMinCardinalityRestriction( p : Synthesis!AssociationMetaclassDef ) {
	to
		c : OWL!MinCardinalityRestriction (
			superClass <- p.getClassesWithProperty(),
			OWLMinCardinality <- literal,
			OWLOnProperty <- p
		),
		literal : OWL!TypedLiteral (
			lexicalForm <- p.minCard.toString(),
			datatypeURI <- thisModule.getIntegerURI()
		)
}
rule addFunctionalProperty( am : Synthesis!AssociationMetaclassDef ) {
	to
		o : OWL!FunctionalProperty (
				isDefinedBy <- am
		)
}




-- =============================================================================
-- BOOLEAN OPERATIONS
-- =============================================================================

rule addIntersectionToClass ( classesInIntersection : Sequence(Synthesis!ClassDef),
							  c : Synthesis!ClassDef) {
	to
		intersection : OWL!IntersectionClass (
			superClass <- c,
			OWLIntersectionOf <- classesInIntersection)
}
rule addUnionToClass ( classesInUnion : Sequence(Synthesis!ClassDef),
							  c : Synthesis!ClassDef) {
	to
		union : OWL!UnionClass (
			superClass <- c,
			OWLUnionOf <- classesInUnion)
}
rule addComplementToClass ( complementClasses : Sequence(Synthesis!ClassDef),
							c: Synthesis!ClassDef) {
	to
		complement: OWL!ComplementClass (
			superClass <- c,
			OWLComplementOf <- complementClasses)
}


-- TODO: Property restrictions
-- =============================================================================
-- INDIVIDUALS
-- =============================================================================
rule Frame2Individual {
	from 
		i : Synthesis!FrameDef (
			i.oclIsTypeOf(Synthesis!FrameDef) and
			i.classes->asSequence()->notEmpty() and 
			Synthesis!ClassDef.allInstances()->asSequence()->includesAll(i.classes->asSequence())
			)
	to
		owlIndividual: OWL!Individual(
			uriRef <- u,
			type <- i.classes->asSequence()),
		u : OWL!URIReference ( fragmentIdentifier <- l, uri <- uri),
		l : OWL!LocalName (name <- i.name),
		uri: OWL!UniformResourceIdentifier (name <- i.name)
}